1.我们将在本章中重新进行度量。使用调用 gettimeofday()来度量程序中的时间。 这个计时器有多精确?它能确定的最小间隔是多少?要对它的工作方式有信心，因为在接下来的所有问题中我们都需要它。您还可以使用其他计时器，比如通过 x86 提供的rdtsc指令使用循环计数器
gettimeofday 精度为微妙级 rdtsc指令，成本与精确度都是纳秒级(取决于cpu使用周期)
rdtsc测试方法参考:How to Benchmark Code Execution Times on Intel® IA-32 and IA-64 Instruction Set Architectures

2.现在，构建一个简单的并发计数器，并测量随着线程数量的增加，多次增加计数器所需的时间。 您正在使用的系统上有多少个 CPU 可用？ 这个数字是否会完全影响您的测量？
fang@fang:~/code/Operating Systream/Lock Usage$ g++ q2.cc -o ./out/q2 -g -lpthread
fang@fang:~/code/Operating Systream/Lock Usage$ ./out/q2 
0.222676
0.247114
0.267917
0.260511
0.233036

查看 CPU 信息:
cat /proc/cpuinfo
查看逻辑cpu的个数
fang@fang:~/code/Operating Systream/Lock Usage$ cat /proc/cpuinfo | grep "processor" | wc -l
2
查看物理cpu的个数
fang@fang:~/code/Operating Systream/Lock Usage$ cat /proc/cpuinfo | grep "physical id" | sort | uniq | wc -l
2
查看每个物理cpu中core的个数(即核数)
fang@fang:~/code/Operating Systream/Lock Usage$ cat /proc/cpuinfo | grep "cpu cores" | uniq
cpu cores       : 1

3.接下来，构建一个 懒惰计数器(sloppy counter) 的版本。 根据线程数以及阈值来衡量其性能。 这些数字是否与您在本章中看到的一致？
