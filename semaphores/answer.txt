课后作业 (编程)
在这个作业中，我们将使用信号量来解决一些常见的的并发问题。 其中很多都来自 Downey 的优秀的书籍 “Little Book of Semaphores”3， 它很好地将一些经典问题结合在一起，并引入了一些新的变体;有兴趣的读者应该看看这本小书来获得更多的乐趣。 以下每个问题都提供了一个代码框架;您的工作是完善代码，使其在给定的信号量下工作。 在 Linux 上，您将使用 Linux 系统提供的信号量;在 Mac(不支持信号量)上，您必须首先构建一个信号量实现(使用锁和条件变量，如本章所述)。好运！

问题：
1.第一个问题就是实现和测试 fork/join 问题的解决方案，如本文所述。 即使在文本中描述了此解决方案， 重新自己实现一遍也是值得的。 even Bach would rewrite Vivaldi， allowing one soon-to-be master to learn from an existing one。 有关详细信息，请参见 fork-join.c。 将添加 sleep(1) 到 child 函数内以确保其正常工作。
fang@fang:~/code/Operating Systream/semaphores$ ./out/fork-join 
parent: begin
child
parent: end

2.现在，我们通过研究集合点问题 rendezvous problem 来对此进行概括。 问题如下：您有两个线程，每个线程将要在代码中进入集合点。 任何一方都不应在另一方进入之前退出代码的这一部分。 该任务使用两个信号量，有关详细信息，请参见 rendezvous.c。
fang@fang:~/code/Operating Systream/semaphores$ gcc rendevous.c -o ./out/rendevous -lpthread
fang@fang:~/code/Operating Systream/semaphores$ ./out/rendevous 
parent: begin
child 1: before
child 2: before
child 1: after
child 2: after
parent: end

3.现在，通过实现屏障（barrier）同步的通用解决方案，更进一步。假设在一段连续的代码中有两个点，称为 P1 和 P2。 在 P1 和 P2 之间放置一个 barrier 可确保所有线程将在任何一个线程执行 P2 之前执行完 P1。 您的任务：编写代码以实现可以这种方式使用的 barrier（）函数。 可以假设您知道 N（正在运行的程序中的线程总数），并且所有 N 个线程都将尝试进入该屏障。 同样，您可能应该使用两个信号量来实现解决方案，并使用其他一些整数来计数。有关详细信息，请参见 barrier.c。

4.现在按照文本中所述，解决读者写者问题。 首先，不用考虑进程饥饿。 有关详细信息，请参见 reader-writer.c 中的代码。 将 sleep（）调用添加到您的代码中，以证明它可以按预期工作****。 你能证明饥饿问题的存在吗？

5.让我们再次看一下读者写者问题，但这一次需要考虑进程饥饿。 您如何确保所有读者和写者运行？ 有关详细信息，请参见 reader-writer-nostarve.c。

6.使用信号量构建一个没有饥饿的互斥量，其中任何试图获取该互斥量的线程都将最终获得它。 有关更多信息，请参见 mutex-nostarve.c 中的代码。


7.喜欢这些问题吗？ 查看 Downey 的免费书籍，以获取更多与他们一样的信息。 并且不要忘记，玩得开心！ 但是，编写代码时总是玩的开心的，不是吗？