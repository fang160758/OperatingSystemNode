5.要注意编译器优化带来的影响。编译器做各种聪明的事情,包括优化掉循环,如果循环中增加的变量后续没有使用。如何确保编译器不优化掉你写的 TLB 大小测算程序的主循环?

gcc 选项-O 启用不同级别的优化。使用-O0(默认)禁用它们。-O3 是最高级别的优化。



6.还有一个需要注意的地方,今天的计算机系统大多有多个 CPU,每个 CPU 当然有自己的 TLB 结构。为了得到准确的测量数据我们需要只在一个 CPU 上运行程序,避免调度器把进程从一个 CPU 调度到另一个去运行。如何做到?(提示:在 Google 上搜索“ pinningthread”相关的信息)如果没有这样做,代码从一个 CPU 移到了另一个,会发生什么情况?

pthread_setaffinity_np
切换 cpu 时成本增加,但时使用新的小 TLB 使速度变快



7.另一个可能发生的问题与初始化有关。如果在访问数组 a 之前没有初始化,第一次访问将非常耗时,由于初始访问开销,比如要求置 0。这会影响你的代码及其计时吗?如何抵消这些潜在的开销?

不会,没有初始化,且计时器不会记录初始化的时间